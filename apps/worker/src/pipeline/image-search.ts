/**
 * Image search and aesthetic scoring service
 * Uses Unsplash API for high-quality images and OpenAI for query generation and scoring
 * Falls back to DALL-E 3 image generation if no suitable image is found
 */

import { openai } from "../clients/openai.js";
import { env } from "../env.js";

const UNSPLASH_API_BASE = "https://api.unsplash.com";
const MIN_AESTHETIC_SCORE = 0.6; // Minimum score to accept an Unsplash image

/**
 * Triggers the Unsplash download endpoint to track image usage
 * Required when using an image (similar to downloading)
 */
async function triggerUnsplashDownload(downloadLocation: string): Promise<void> {
  if (!env.UNSPLASH_ACCESS_KEY || !downloadLocation) {
    return;
  }

  try {
    // The download endpoint requires the access key in the URL
    const downloadUrl = `${downloadLocation}&client_id=${env.UNSPLASH_ACCESS_KEY}`;
    await fetch(downloadUrl, { method: "GET" });
    // We don't need to wait for or process the response
  } catch (error) {
    // Silently fail - download tracking is not critical
    console.debug("[image-search] Failed to trigger download tracking:", error);
  }
}

export interface ImageSearchResult {
  url: string; // Regular size URL from photo.urls.regular
  thumbnailUrl: string; // Thumbnail URL from photo.urls.thumb
  description?: string;
  photographer?: string;
  photographerProfileUrl?: string; // Link to photographer's Unsplash profile
  unsplashPhotoUrl?: string; // Link to photo on Unsplash
  downloadLocation?: string; // photo.links.download_location for download tracking
  aestheticScore: number;
  searchQuery: string;
  isGenerated?: boolean; // true if generated by DALL-E, false if from Unsplash
}

/**
 * Generates a search query based on analysis content
 */
async function generateImageSearchQuery(
  summary: string,
  topic: string,
  claims: string[]
): Promise<string> {
  const claimsText = claims.slice(0, 3).join(". ");
  const prompt = `Based on this fact-check analysis, generate a concise, specific image search query (2-5 words) that would find a visually appealing, relevant photograph.

Analysis summary: "${summary}"
Topic: ${topic}
Key claims: ${claimsText}

Generate a search query that would find a high-quality, aesthetically pleasing image relevant to this content. Examples:
- "olive trees palestine farmer" for content about Palestinian agriculture
- "modern gym fitness equipment" for content about exercise and muscle gain
- "medical research laboratory" for health/science content
- "political debate podium" for political content

Return ONLY the search query, nothing else.`;

  try {
    const response = await openai.chat.completions.create({
      model: "gpt-4o-mini",
      messages: [
        {
          role: "system",
          content: "You are an expert at generating image search queries. Return only the query text."
        },
        {
          role: "user",
          content: prompt
        }
      ],
      temperature: 0.7,
      max_tokens: 20
    });

    const query = response.choices[0]?.message?.content?.trim() || "";
    return query || `${topic} ${summary.split(" ").slice(0, 3).join(" ")}`;
  } catch (error) {
    console.error("[image-search] Failed to generate query:", error);
    // Fallback to topic-based query
    return `${topic} ${summary.split(" ").slice(0, 3).join(" ")}`;
  }
}

/**
 * Scores images for aesthetic quality using OpenAI vision
 */
async function scoreImageAesthetics(imageUrl: string): Promise<number> {
  try {
    const response = await openai.chat.completions.create({
      model: "gpt-4o",
      messages: [
        {
          role: "system",
          content:
            "You are an expert at evaluating image aesthetic quality. Score images from 0-1 based on: composition, lighting, color harmony, professional quality, visual appeal. Return only a number between 0 and 1."
        },
        {
          role: "user",
          content: [
            {
              type: "text",
              text: "Score this image's aesthetic quality from 0-1. Consider: composition, lighting, color harmony, professional quality, visual appeal. Return only a number."
            },
            {
              type: "image_url",
              image_url: { url: imageUrl }
            }
          ]
        }
      ],
      max_tokens: 10
    });

    const scoreText = response.choices[0]?.message?.content?.trim() || "0.5";
    const score = parseFloat(scoreText);
    return Math.max(0, Math.min(1, isNaN(score) ? 0.5 : score));
  } catch (error) {
    console.error("[image-search] Failed to score image:", error);
    return 0.5; // Default score
  }
}

/**
 * Generates an image using DALL-E 3 as a fallback
 */
async function generateImageWithDalle(
  summary: string,
  topic: string,
  claims: string[]
): Promise<ImageSearchResult | null> {
  try {
    // Generate a detailed prompt for DALL-E
    const claimsText = claims.slice(0, 2).join(". ");
    const prompt = `Create a professional, high-quality photograph-style image that visually represents this fact-check analysis. The image should be aesthetically pleasing, well-composed, and relevant to the content.

Analysis summary: "${summary}"
Topic: ${topic}
Key claims: ${claimsText}

Generate a detailed DALL-E prompt (2-3 sentences) describing a professional photograph that would represent this content. The image should be:
- Photorealistic and high-quality
- Well-composed with good lighting
- Relevant to the topic and claims
- Professional and trustworthy in appearance
- Suitable for a fact-checking application

Return ONLY the DALL-E prompt, nothing else.`;

    const response = await openai.chat.completions.create({
      model: "gpt-4o-mini",
      messages: [
        {
          role: "system",
          content:
            "You are an expert at creating detailed image generation prompts. Return only the prompt text."
        },
        {
          role: "user",
          content: prompt
        }
      ],
      temperature: 0.7,
      max_tokens: 150
    });

    const dallePrompt = response.choices[0]?.message?.content?.trim();
    if (!dallePrompt) {
      console.warn("[image-search] Failed to generate DALL-E prompt");
      return null;
    }

    console.info(`[image-search] Generating image with DALL-E: "${dallePrompt.slice(0, 100)}..."`);

    // Generate image with DALL-E 3
    const imageResponse = await openai.images.generate({
      model: "dall-e-3",
      prompt: dallePrompt,
      size: "1024x1024",
      quality: "standard",
      n: 1
    });

    const imageUrl = imageResponse.data[0]?.url;
    if (!imageUrl) {
      console.warn("[image-search] DALL-E did not return an image URL");
      return null;
    }

    console.info("[image-search] Successfully generated image with DALL-E 3");

    return {
      url: imageUrl,
      thumbnailUrl: imageUrl, // DALL-E returns full-size images
      description: dallePrompt,
      photographer: "DALL-E 3",
      aestheticScore: 0.85, // Assume high quality for generated images
      searchQuery: `Generated: ${dallePrompt.slice(0, 50)}...`,
      isGenerated: true // No Unsplash attribution needed for generated images
    };
  } catch (error) {
    console.error("[image-search] Error generating image with DALL-E:", error);
    return null;
  }
}

/**
 * Searches Unsplash for images and returns the highest-scoring one
 * Falls back to DALL-E 3 generation if no suitable image is found
 */
export async function findBestImage(
  summary: string,
  topic: string,
  claims: string[]
): Promise<ImageSearchResult | null> {
  // Try Unsplash first if API key is configured
  if (env.UNSPLASH_ACCESS_KEY) {
    try {
      // Generate search query
      const searchQuery = await generateImageSearchQuery(summary, topic, claims);
      console.info(`[image-search] Searching Unsplash for: "${searchQuery}"`);
      console.info(`[image-search] Unsplash API key present: ${env.UNSPLASH_ACCESS_KEY ? "Yes" : "No"}`);

      // Search Unsplash
      const searchUrl = `${UNSPLASH_API_BASE}/search/photos?query=${encodeURIComponent(searchQuery)}&per_page=10&orientation=landscape`;
      console.info(`[image-search] Unsplash search URL: ${searchUrl}`);
      
      const searchResponse = await fetch(searchUrl, {
        headers: {
          Authorization: `Client-ID ${env.UNSPLASH_ACCESS_KEY}`,
          "Accept-Version": "v1"
        }
      });

      console.info(`[image-search] Unsplash API response status: ${searchResponse.status}`);

      if (searchResponse.ok) {
        const searchData = await searchResponse.json() as {
          results?: Array<{
            id: string;
            urls: {
              regular: string;
              thumb: string;
              small: string;
            };
            links: {
              download_location: string;
              html: string;
            };
            description?: string;
            alt_description?: string;
            user: {
              name: string;
              username: string;
              links: {
                html: string;
              };
            };
          }>;
        };

        if (searchData.results && searchData.results.length > 0) {
          // Score top 5 images and pick the best
          const candidates = searchData.results.slice(0, 5);
          const scoredImages = await Promise.all(
            candidates.map(async (image) => {
              const aestheticScore = await scoreImageAesthetics(image.urls.regular);
              
              // Build photographer profile URL with UTM parameters
              const photographerProfileUrl = `${image.user.links.html}?utm_source=vett&utm_medium=referral`;
              
              return {
                url: image.urls.regular, // Use hotlinked URL from photo.urls
                thumbnailUrl: image.urls.thumb,
                description: image.description || image.alt_description,
                photographer: image.user.name,
                photographerProfileUrl,
                unsplashPhotoUrl: `${image.links.html}?utm_source=vett&utm_medium=referral`,
                downloadLocation: image.links.download_location,
                aestheticScore,
                searchQuery,
                isGenerated: false
              };
            })
          );

          // Sort by aesthetic score and check if best meets threshold
          scoredImages.sort((a, b) => b.aestheticScore - a.aestheticScore);
          const bestImage = scoredImages[0];

          if (bestImage.aestheticScore >= MIN_AESTHETIC_SCORE) {
            console.info(
              `[image-search] Selected Unsplash image with aesthetic score: ${bestImage.aestheticScore.toFixed(2)}`
            );
            
            // Trigger download endpoint to track usage (required by Unsplash guidelines)
            if (bestImage.downloadLocation) {
              await triggerUnsplashDownload(bestImage.downloadLocation);
            }
            
            return bestImage;
          } else {
            console.warn(
              `[image-search] Best Unsplash image score (${bestImage.aestheticScore.toFixed(2)}) below threshold (${MIN_AESTHETIC_SCORE}), falling back to DALL-E`
            );
          }
        } else {
          console.warn("[image-search] No Unsplash images found in search results, falling back to DALL-E");
          try {
            const responseText = await searchResponse.clone().text();
            console.debug(`[image-search] Unsplash API response body: ${responseText.substring(0, 500)}`);
          } catch (e) {
            // Ignore error reading response
          }
        }
      } else {
        try {
          const errorText = await searchResponse.text();
          console.error(
            `[image-search] Unsplash API error (${searchResponse.status}): ${errorText.substring(0, 500)}`
          );
        } catch (e) {
          console.error(`[image-search] Unsplash API error (${searchResponse.status}): Failed to read error response`);
        }
        console.info("[image-search] Falling back to DALL-E generation");
      }
    } catch (error) {
      console.error("[image-search] Error searching Unsplash:", error);
      if (error instanceof Error) {
        console.error("[image-search] Error details:", error.message, error.stack);
      }
      console.info("[image-search] Falling back to DALL-E generation");
    }
  } else {
    console.warn("[image-search] Unsplash API key not configured, using DALL-E generation");
  }

  // Fallback to DALL-E 3 image generation
  console.info("[image-search] Generating image with DALL-E 3 as fallback");
  const generatedImage = await generateImageWithDalle(summary, topic, claims);

  if (generatedImage) {
    return generatedImage;
  }

  console.error("[image-search] Both Unsplash search and DALL-E generation failed");
  return null;
}

